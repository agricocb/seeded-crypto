<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DiceKeys Seeded Cryptography Library: PublicKey Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DiceKeys Seeded Cryptography Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_public_key.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="class_public_key-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PublicKey Class Reference<div class="ingroups"><a class="el" href="group___derived_from_seeds.html">Derived Keys</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A <a class="el" href="class_public_key.html" title="A PublicKey is used to seal messages, in combination with a PrivateKey which can unseal them....">PublicKey</a> is used to <em>seal</em> messages, in combination with a <a class="el" href="class_private_key.html" title="A PrivateKey is used to unseal messages sealed with its corresponding PublicKey. The PrivateKey and P...">PrivateKey</a> which can <em>unseal</em> them. The key pair of this <a class="el" href="class_public_key.html" title="A PublicKey is used to seal messages, in combination with a PrivateKey which can unseal them....">PublicKey</a> and the matching <a class="el" href="class_private_key.html" title="A PrivateKey is used to unseal messages sealed with its corresponding PublicKey. The PrivateKey and P...">PrivateKey</a> are generated from a seed and a set of key-derivation specified options in JSON format <a class="el" href="key_derivation_options_format.html">Key-Derivation Options JSON Format</a>.  
 <a href="class_public_key.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="public-key_8hpp_source.html">public-key.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a91229754236efbd63b50e93b665eeacf"><td class="memItemLeft" align="right" valign="top"><a id="a91229754236efbd63b50e93b665eeacf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_public_key.html#a91229754236efbd63b50e93b665eeacf">PublicKey</a> (const std::vector&lt; unsigned char &gt; &amp;<a class="el" href="class_public_key.html#a7e62a49618c5dbd4cc415a0aa44943a6">publicKeyBytes</a>, const std::string &amp;<a class="el" href="class_public_key.html#abeb1c748bb7934461fd8e0d74e391f38">keyDerivationOptionsJson</a>)</td></tr>
<tr class="memdesc:a91229754236efbd63b50e93b665eeacf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new Public Key object by passing its members. <br /></td></tr>
<tr class="separator:a91229754236efbd63b50e93b665eeacf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8995e1456c51f610ebee3ce2c452ef47"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_public_key.html#a8995e1456c51f610ebee3ce2c452ef47">toJson</a> (int indent=-1, const char indent_char=' ') const</td></tr>
<tr class="memdesc:a8995e1456c51f610ebee3ce2c452ef47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize this object to a JSON-formatted string.  <a href="class_public_key.html#a8995e1456c51f610ebee3ce2c452ef47">More...</a><br /></td></tr>
<tr class="separator:a8995e1456c51f610ebee3ce2c452ef47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4e3dccf419b8fdb2e15ccab3894e824"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_public_key.html#af4e3dccf419b8fdb2e15ccab3894e824">sealToCiphertextOnly</a> (const unsigned char *message, const size_t messageLength, const std::string &amp;postDecryptionInstructions={}) const</td></tr>
<tr class="memdesc:af4e3dccf419b8fdb2e15ccab3894e824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seal a plaintext message.  <a href="class_public_key.html#af4e3dccf419b8fdb2e15ccab3894e824">More...</a><br /></td></tr>
<tr class="separator:af4e3dccf419b8fdb2e15ccab3894e824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad58b54babf9c99b001bd7d25cd24ceb7"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_public_key.html#ad58b54babf9c99b001bd7d25cd24ceb7">sealToCiphertextOnly</a> (const <a class="el" href="class_sodium_buffer.html">SodiumBuffer</a> &amp;message, const std::string &amp;postDecryptionInstructions={}) const</td></tr>
<tr class="memdesc:ad58b54babf9c99b001bd7d25cd24ceb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seal a plaintext message.  <a href="class_public_key.html#ad58b54babf9c99b001bd7d25cd24ceb7">More...</a><br /></td></tr>
<tr class="separator:ad58b54babf9c99b001bd7d25cd24ceb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade51af3f61dd5b90a466756ab26b44d4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_packaged_sealed_message.html">PackagedSealedMessage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_public_key.html#ade51af3f61dd5b90a466756ab26b44d4">seal</a> (const <a class="el" href="class_sodium_buffer.html">SodiumBuffer</a> &amp;message, const std::string &amp;postDecryptionInstructions) const</td></tr>
<tr class="memdesc:ade51af3f61dd5b90a466756ab26b44d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seal a plaintext message and then package the results along with its keyDerivationOptionsJson and postDecryptionInstructions into a SealedPackagedMessage.  <a href="class_public_key.html#ade51af3f61dd5b90a466756ab26b44d4">More...</a><br /></td></tr>
<tr class="separator:ade51af3f61dd5b90a466756ab26b44d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1e9d86705561fc03cf21b191c7a1094"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_packaged_sealed_message.html">PackagedSealedMessage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_public_key.html#ad1e9d86705561fc03cf21b191c7a1094">seal</a> (const std::vector&lt; unsigned char &gt; &amp;message, const std::string &amp;postDecryptionInstructions=&quot;&quot;) const</td></tr>
<tr class="memdesc:ad1e9d86705561fc03cf21b191c7a1094"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seal a plaintext message and then package the results along with its keyDerivationOptionsJson and postDecryptionInstructions into a SealedPackagedMessage.  <a href="class_public_key.html#ad1e9d86705561fc03cf21b191c7a1094">More...</a><br /></td></tr>
<tr class="separator:ad1e9d86705561fc03cf21b191c7a1094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3b49ec0f32b20538b67799734f78a17"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_packaged_sealed_message.html">PackagedSealedMessage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_public_key.html#ab3b49ec0f32b20538b67799734f78a17">seal</a> (const std::string &amp;message, const std::string &amp;postDecryptionInstructions={}) const</td></tr>
<tr class="memdesc:ab3b49ec0f32b20538b67799734f78a17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seal a plaintext message and then package the results along with its keyDerivationOptionsJson and postDecryptionInstructions into a SealedPackagedMessage.  <a href="class_public_key.html#ab3b49ec0f32b20538b67799734f78a17">More...</a><br /></td></tr>
<tr class="separator:ab3b49ec0f32b20538b67799734f78a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f06b2b57eee7e23b21f3b3e2b5f627f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_packaged_sealed_message.html">PackagedSealedMessage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_public_key.html#a6f06b2b57eee7e23b21f3b3e2b5f627f">seal</a> (const unsigned char *message, const size_t messageLength, const std::string &amp;postDecryptionInstructions) const</td></tr>
<tr class="memdesc:a6f06b2b57eee7e23b21f3b3e2b5f627f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seal a plaintext message and then package the results along with its keyDerivationOptionsJson and postDecryptionInstructions into a SealedPackagedMessage.  <a href="class_public_key.html#a6f06b2b57eee7e23b21f3b3e2b5f627f">More...</a><br /></td></tr>
<tr class="separator:a6f06b2b57eee7e23b21f3b3e2b5f627f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02e36c4c9a03a54e02cdf9eae44cd3d3"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_public_key.html#a02e36c4c9a03a54e02cdf9eae44cd3d3">getPublicKeyBytes</a> () const</td></tr>
<tr class="memdesc:a02e36c4c9a03a54e02cdf9eae44cd3d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the copy of the raw public key bytes used by lib-sodium.  <a href="class_public_key.html#a02e36c4c9a03a54e02cdf9eae44cd3d3">More...</a><br /></td></tr>
<tr class="separator:a02e36c4c9a03a54e02cdf9eae44cd3d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a488900ad04bb867a0891963862981bea"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_public_key.html#a488900ad04bb867a0891963862981bea">getKeyDerivationOptionsJson</a> () const</td></tr>
<tr class="memdesc:a488900ad04bb867a0891963862981bea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the JSON-formatted key-derivation options string used to generate the public-private key pair.  <a href="class_public_key.html#a488900ad04bb867a0891963862981bea">More...</a><br /></td></tr>
<tr class="separator:a488900ad04bb867a0891963862981bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a234a1ded392f749ccb4b3135f2a08823"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_sodium_buffer.html">SodiumBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_public_key.html#a234a1ded392f749ccb4b3135f2a08823">toSerializedBinaryForm</a> () const</td></tr>
<tr class="memdesc:a234a1ded392f749ccb4b3135f2a08823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize to byte array as a list of: (publicKeyBytes, keyDerivationOptionsJson)  <a href="class_public_key.html#a234a1ded392f749ccb4b3135f2a08823">More...</a><br /></td></tr>
<tr class="separator:a234a1ded392f749ccb4b3135f2a08823"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a798ba8ad96dd713036f7b7234d0d59c7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_public_key.html">PublicKey</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_public_key.html#a798ba8ad96dd713036f7b7234d0d59c7">fromJson</a> (const std::string &amp;publicKeyAsJson)</td></tr>
<tr class="memdesc:a798ba8ad96dd713036f7b7234d0d59c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="class_public_key.html" title="A PublicKey is used to seal messages, in combination with a PrivateKey which can unseal them....">PublicKey</a> from a JSON string.  <a href="class_public_key.html#a798ba8ad96dd713036f7b7234d0d59c7">More...</a><br /></td></tr>
<tr class="separator:a798ba8ad96dd713036f7b7234d0d59c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac83f10e64fdf7f8d219848a11c0fee45"><td class="memItemLeft" align="right" valign="top">static const std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_public_key.html#ac83f10e64fdf7f8d219848a11c0fee45">sealToCiphertextOnly</a> (const <a class="el" href="class_sodium_buffer.html">SodiumBuffer</a> &amp;message, const std::vector&lt; unsigned char &gt; &amp;publicKey, const std::string &amp;postDecryptionInstructions={})</td></tr>
<tr class="memdesc:ac83f10e64fdf7f8d219848a11c0fee45"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>Avoid Using</em> Seal a message using a raw libsodium public key.  <a href="class_public_key.html#ac83f10e64fdf7f8d219848a11c0fee45">More...</a><br /></td></tr>
<tr class="separator:ac83f10e64fdf7f8d219848a11c0fee45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba0b54c83b662337acbdb1fb71923cd"><td class="memItemLeft" align="right" valign="top">static const std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_public_key.html#a1ba0b54c83b662337acbdb1fb71923cd">sealToCiphertextOnly</a> (const unsigned char *message, const size_t messageLength, const std::vector&lt; unsigned char &gt; &amp;publicKey, const std::string &amp;postDecryptionInstructions={})</td></tr>
<tr class="memdesc:a1ba0b54c83b662337acbdb1fb71923cd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>Avoid Using</em> Seal a message using a raw libsodium public key.  <a href="class_public_key.html#a1ba0b54c83b662337acbdb1fb71923cd">More...</a><br /></td></tr>
<tr class="separator:a1ba0b54c83b662337acbdb1fb71923cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac503c854b95d03309d16b7956a6eb33d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_public_key.html">PublicKey</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_public_key.html#ac503c854b95d03309d16b7956a6eb33d">fromSerializedBinaryForm</a> (<a class="el" href="class_sodium_buffer.html">SodiumBuffer</a> serializedBinaryForm)</td></tr>
<tr class="memdesc:ac503c854b95d03309d16b7956a6eb33d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize from a byte array stored as a list of: (publicKeyBytes, keyDerivationOptionsJson)  <a href="class_public_key.html#ac503c854b95d03309d16b7956a6eb33d">More...</a><br /></td></tr>
<tr class="separator:ac503c854b95d03309d16b7956a6eb33d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a7e62a49618c5dbd4cc415a0aa44943a6"><td class="memItemLeft" align="right" valign="top"><a id="a7e62a49618c5dbd4cc415a0aa44943a6"></a>
const std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_public_key.html#a7e62a49618c5dbd4cc415a0aa44943a6">publicKeyBytes</a></td></tr>
<tr class="memdesc:a7e62a49618c5dbd4cc415a0aa44943a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The binary representation of the public key used for sealing. <br /></td></tr>
<tr class="separator:a7e62a49618c5dbd4cc415a0aa44943a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeb1c748bb7934461fd8e0d74e391f38"><td class="memItemLeft" align="right" valign="top"><a id="abeb1c748bb7934461fd8e0d74e391f38"></a>
const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_public_key.html#abeb1c748bb7934461fd8e0d74e391f38">keyDerivationOptionsJson</a></td></tr>
<tr class="memdesc:abeb1c748bb7934461fd8e0d74e391f38"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="key_derivation_options_format.html">Key-Derivation Options JSON Format</a> string used to specify how this key is derived. <br /></td></tr>
<tr class="separator:abeb1c748bb7934461fd8e0d74e391f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A <a class="el" href="class_public_key.html" title="A PublicKey is used to seal messages, in combination with a PrivateKey which can unseal them....">PublicKey</a> is used to <em>seal</em> messages, in combination with a <a class="el" href="class_private_key.html" title="A PrivateKey is used to unseal messages sealed with its corresponding PublicKey. The PrivateKey and P...">PrivateKey</a> which can <em>unseal</em> them. The key pair of this <a class="el" href="class_public_key.html" title="A PublicKey is used to seal messages, in combination with a PrivateKey which can unseal them....">PublicKey</a> and the matching <a class="el" href="class_private_key.html" title="A PrivateKey is used to unseal messages sealed with its corresponding PublicKey. The PrivateKey and P...">PrivateKey</a> are generated from a seed and a set of key-derivation specified options in JSON format <a class="el" href="key_derivation_options_format.html">Key-Derivation Options JSON Format</a>. </p>
<p>To derive a public key from a seed, first derive the corresponding <a class="el" href="class_private_key.html" title="A PrivateKey is used to unseal messages sealed with its corresponding PublicKey. The PrivateKey and P...">PrivateKey</a> and then call <a class="el" href="class_private_key.html#a808ca1477d3e74f986744578a78bf395" title="Get the PublicKey used to seal messages that can be unsealed with this PrivateKey.">PrivateKey::getPublicKey</a>.</p>
<p>Sealing a message (<em>plaintext</em>) creates a _ciphertext which contains the message but from which observers who do not have the <a class="el" href="class_private_key.html" title="A PrivateKey is used to unseal messages sealed with its corresponding PublicKey. The PrivateKey and P...">PrivateKey</a> cannot discern the contents of the message. Sealing also provides integrity-protection, which will prevent the message from being unsealed if it is modified. We use the verbs seal and unseal, rather than encrypt and decrypt, because the encrypting alone does not confer that the message includes an integrity (message authentication) code to prove that the ciphertext has not been tampered with.</p>
<p>Note that sealing data does not prevent attackers who capture a sealed message (ciphertext) in transit with another validly-sealed message. A <a class="el" href="class_signing_key.html" title="SigningKeys generate signatures of messages which can then be used by the corresponding SignatureVeri...">SigningKey</a> can be used to sign messages that another party can verify that the message has not been forged or modified since the signer approved it. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a798ba8ad96dd713036f7b7234d0d59c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a798ba8ad96dd713036f7b7234d0d59c7">&#9670;&nbsp;</a></span>fromJson()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_public_key.html">PublicKey</a> PublicKey::fromJson </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>publicKeyAsJson</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="class_public_key.html" title="A PublicKey is used to seal messages, in combination with a PrivateKey which can unseal them....">PublicKey</a> from a JSON string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">publicKeyAsJson</td><td>The JSON encoding of a <a class="el" href="class_public_key.html" title="A PublicKey is used to seal messages, in combination with a PrivateKey which can unseal them....">PublicKey</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac503c854b95d03309d16b7956a6eb33d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac503c854b95d03309d16b7956a6eb33d">&#9670;&nbsp;</a></span>fromSerializedBinaryForm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_public_key.html">PublicKey</a> PublicKey::fromSerializedBinaryForm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sodium_buffer.html">SodiumBuffer</a>&#160;</td>
          <td class="paramname"><em>serializedBinaryForm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deserialize from a byte array stored as a list of: (publicKeyBytes, keyDerivationOptionsJson) </p>
<p>Stored in <a class="el" href="class_sodium_buffer.html" title="A byte array containing a length and a pointer to memory (the data field), which ensures data is eras...">SodiumBuffer</a>'s fixed-length list format. Strings are stored as UTF8 byte arrays. </p>

</div>
</div>
<a id="a488900ad04bb867a0891963862981bea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a488900ad04bb867a0891963862981bea">&#9670;&nbsp;</a></span>getKeyDerivationOptionsJson()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string PublicKey::getKeyDerivationOptionsJson </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the JSON-formatted key-derivation options string used to generate the public-private key pair. </p>
<dl class="section return"><dt>Returns</dt><dd>const std::string in <a class="el" href="key_derivation_options_format.html">Key-Derivation Options JSON Format</a> </dd></dl>

</div>
</div>
<a id="a02e36c4c9a03a54e02cdf9eae44cd3d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02e36c4c9a03a54e02cdf9eae44cd3d3">&#9670;&nbsp;</a></span>getPublicKeyBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; unsigned char &gt; PublicKey::getPublicKeyBytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the copy of the raw public key bytes used by lib-sodium. </p>
<dl class="section return"><dt>Returns</dt><dd>const std::vector&lt;unsigned char&gt; </dd></dl>

</div>
</div>
<a id="ade51af3f61dd5b90a466756ab26b44d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade51af3f61dd5b90a466756ab26b44d4">&#9670;&nbsp;</a></span>seal() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_packaged_sealed_message.html">PackagedSealedMessage</a> PublicKey::seal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sodium_buffer.html">SodiumBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>postDecryptionInstructions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Seal a plaintext message and then package the results along with its keyDerivationOptionsJson and postDecryptionInstructions into a SealedPackagedMessage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>The plaintext message to seal </td></tr>
    <tr><td class="paramname">postDecryptionInstructions</td><td>If this optional string is passed, the same string must be passed to unseal the message. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const <a class="el" href="class_packaged_sealed_message.html" title="When a message is sealed, the ciphertext is packaged with the keyDerivationOptionsJson in Key-Derivat...">PackagedSealedMessage</a> Everything needed to re-derive the <a class="el" href="class_private_key.html" title="A PrivateKey is used to unseal messages sealed with its corresponding PublicKey. The PrivateKey and P...">PrivateKey</a> from the seed (except the seed string iteslf) and unseal the message. </dd></dl>

</div>
</div>
<a id="ab3b49ec0f32b20538b67799734f78a17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3b49ec0f32b20538b67799734f78a17">&#9670;&nbsp;</a></span>seal() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_packaged_sealed_message.html">PackagedSealedMessage</a> PublicKey::seal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>postDecryptionInstructions</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Seal a plaintext message and then package the results along with its keyDerivationOptionsJson and postDecryptionInstructions into a SealedPackagedMessage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>The plaintext message to seal </td></tr>
    <tr><td class="paramname">postDecryptionInstructions</td><td>If this optional string is passed, the same string must be passed to unseal the message. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const <a class="el" href="class_packaged_sealed_message.html" title="When a message is sealed, the ciphertext is packaged with the keyDerivationOptionsJson in Key-Derivat...">PackagedSealedMessage</a> Everything needed to re-derive the <a class="el" href="class_private_key.html" title="A PrivateKey is used to unseal messages sealed with its corresponding PublicKey. The PrivateKey and P...">PrivateKey</a> from the seed (except the seed string iteslf) and unseal the message. </dd></dl>

</div>
</div>
<a id="ad1e9d86705561fc03cf21b191c7a1094"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1e9d86705561fc03cf21b191c7a1094">&#9670;&nbsp;</a></span>seal() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_packaged_sealed_message.html">PackagedSealedMessage</a> PublicKey::seal </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>postDecryptionInstructions</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Seal a plaintext message and then package the results along with its keyDerivationOptionsJson and postDecryptionInstructions into a SealedPackagedMessage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>The plaintext message to seal </td></tr>
    <tr><td class="paramname">postDecryptionInstructions</td><td>If this optional string is passed, the same string must be passed to unseal the message. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const <a class="el" href="class_packaged_sealed_message.html" title="When a message is sealed, the ciphertext is packaged with the keyDerivationOptionsJson in Key-Derivat...">PackagedSealedMessage</a> Everything needed to re-derive the <a class="el" href="class_private_key.html" title="A PrivateKey is used to unseal messages sealed with its corresponding PublicKey. The PrivateKey and P...">PrivateKey</a> from the seed (except the seed string iteslf) and unseal the message. </dd></dl>

</div>
</div>
<a id="a6f06b2b57eee7e23b21f3b3e2b5f627f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f06b2b57eee7e23b21f3b3e2b5f627f">&#9670;&nbsp;</a></span>seal() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_packaged_sealed_message.html">PackagedSealedMessage</a> PublicKey::seal </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>messageLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>postDecryptionInstructions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Seal a plaintext message and then package the results along with its keyDerivationOptionsJson and postDecryptionInstructions into a SealedPackagedMessage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>The plaintext message to seal </td></tr>
    <tr><td class="paramname">messageLength</td><td>The length of the plaintext to seal </td></tr>
    <tr><td class="paramname">postDecryptionInstructions</td><td>If this optional string is passed, the same string must be passed to unseal the message. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const <a class="el" href="class_packaged_sealed_message.html" title="When a message is sealed, the ciphertext is packaged with the keyDerivationOptionsJson in Key-Derivat...">PackagedSealedMessage</a> Everything needed to re-derive the <a class="el" href="class_private_key.html" title="A PrivateKey is used to unseal messages sealed with its corresponding PublicKey. The PrivateKey and P...">PrivateKey</a> from the seed (except the seed string iteslf) and unseal the message. </dd></dl>

</div>
</div>
<a id="ad58b54babf9c99b001bd7d25cd24ceb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad58b54babf9c99b001bd7d25cd24ceb7">&#9670;&nbsp;</a></span>sealToCiphertextOnly() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; unsigned char &gt; PublicKey::sealToCiphertextOnly </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sodium_buffer.html">SodiumBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>postDecryptionInstructions</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Seal a plaintext message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>The plaintext message to seal </td></tr>
    <tr><td class="paramname">postDecryptionInstructions</td><td>If this optional string is passed, the same string must be passed to unseal the message. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const std::vector&lt;unsigned char&gt; </dd></dl>

</div>
</div>
<a id="ac83f10e64fdf7f8d219848a11c0fee45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac83f10e64fdf7f8d219848a11c0fee45">&#9670;&nbsp;</a></span>sealToCiphertextOnly() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; unsigned char &gt; PublicKey::sealToCiphertextOnly </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sodium_buffer.html">SodiumBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>publicKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>postDecryptionInstructions</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><em>Avoid Using</em> Seal a message using a raw libsodium public key. </p>
<p>Instead of using this static method, we recommend you use the seal method on an instance of a <a class="el" href="class_public_key.html" title="A PublicKey is used to seal messages, in combination with a PrivateKey which can unseal them....">PublicKey</a> object. This static method is used internally to libsodium's seal operation. We have exposed so that others can replicate the internals of this class if necessary, but recommend that only when there are reasons not to call the non-static seal operation on an instance of this class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>The plaintext message to seal </td></tr>
    <tr><td class="paramname">publicKey</td><td>The public key matching the private key used to unseal it. </td></tr>
    <tr><td class="paramname">postDecryptionInstructions</td><td>If this optional string is passed, the same string must be passed to unseal the message. RefPDI. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const std::vector&lt;unsigned char&gt; The sealed message (ciphertext) </dd></dl>

</div>
</div>
<a id="af4e3dccf419b8fdb2e15ccab3894e824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4e3dccf419b8fdb2e15ccab3894e824">&#9670;&nbsp;</a></span>sealToCiphertextOnly() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; unsigned char &gt; PublicKey::sealToCiphertextOnly </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>messageLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>postDecryptionInstructions</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Seal a plaintext message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>The plaintxt message to seal </td></tr>
    <tr><td class="paramname">messageLength</td><td>The length of the plaintext message in bytes </td></tr>
    <tr><td class="paramname">postDecryptionInstructions</td><td>If this optional string is passed, the same string must be passed to unseal the message. It can be used to pair a secret (sealed) message with public instructions about what should happen after the message is unsealed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const std::vector&lt;unsigned char&gt; </dd></dl>

</div>
</div>
<a id="a1ba0b54c83b662337acbdb1fb71923cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ba0b54c83b662337acbdb1fb71923cd">&#9670;&nbsp;</a></span>sealToCiphertextOnly() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; unsigned char &gt; PublicKey::sealToCiphertextOnly </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>messageLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>publicKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>postDecryptionInstructions</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><em>Avoid Using</em> Seal a message using a raw libsodium public key. </p>
<p>Instead of using this static method, we recommend you use the seal method on an instance of a <a class="el" href="class_public_key.html" title="A PublicKey is used to seal messages, in combination with a PrivateKey which can unseal them....">PublicKey</a> object. This static method is used internally to libsodium's seal operation. We have exposed so that others can replicate the internals of this class if necessary, but recommend that only when there are reasons not to call the non-static seal operation on an instance of this class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>The plaintext message to seal </td></tr>
    <tr><td class="paramname">messageLength</td><td>The length of the plaintext message to seal (in bytes) </td></tr>
    <tr><td class="paramname">publicKey</td><td>The public key matching the private key used to unseal it. </td></tr>
    <tr><td class="paramname">postDecryptionInstructions</td><td>If this optional string is passed, the same string must be passed to unseal the message. RefPDI. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const std::vector&lt;unsigned char&gt; The sealed message (ciphertext) </dd></dl>

</div>
</div>
<a id="a8995e1456c51f610ebee3ce2c452ef47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8995e1456c51f610ebee3ce2c452ef47">&#9670;&nbsp;</a></span>toJson()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string PublicKey::toJson </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>indent_char</em> = <code>'&#160;'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialize this object to a JSON-formatted string. </p>
<p>It can be reconstituted by calling the constructor with this string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indent</td><td>The number of characters to indent the JSON (optional) </td></tr>
    <tr><td class="paramname">indent_char</td><td>The character with which to indent the JSON (optional) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const std::string </dd></dl>

</div>
</div>
<a id="a234a1ded392f749ccb4b3135f2a08823"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a234a1ded392f749ccb4b3135f2a08823">&#9670;&nbsp;</a></span>toSerializedBinaryForm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_sodium_buffer.html">SodiumBuffer</a> PublicKey::toSerializedBinaryForm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialize to byte array as a list of: (publicKeyBytes, keyDerivationOptionsJson) </p>
<p>Stored in <a class="el" href="class_sodium_buffer.html" title="A byte array containing a length and a pointer to memory (the data field), which ensures data is eras...">SodiumBuffer</a>'s fixed-length list format. Strings are stored as UTF8 byte arrays. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/stuar/git/dicekeys-seeded-crypto/lib-seeded/<a class="el" href="public-key_8hpp_source.html">public-key.hpp</a></li>
<li>C:/Users/stuar/git/dicekeys-seeded-crypto/lib-seeded/public-key.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_public_key.html">PublicKey</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
